; State machines to emit HDLC encoded data
.define CLK_INTERRUPT 4     ; IRQ number for clock falling edge
.define CLK_ENABLE_IRQ 5    ; IRQ to enable clock
.define FLAG_SENT_IRQ 6     ; IRQ when flag is completed 

;Program for enabling/disabling clock when the flag is completed
.program clock_enable
set x, 0                    ; Clock disabled by default
irq clear CLK_ENABLE_IRQ    ; Clear IRQ for clock enabled
.wrap_target
check_command:
pull noblock                ; Gets clock enable order from TX FIFO
mov osr, x                  ; If TX FIFO is no empty, OSR will be updated
jmp !x wait_flag            ; Request of disabling clock will wait for flag
enable_clock:
; Clock is enabled
irq set CLK_ENABLE_IRQ      ; Enable clock
jmp check_command           ; Check next command

wait_flag:
;Waits for the flag end transmission
wait 1 irq FLAG_SENT_IRQ
irq clear CLK_ENABLE_IRQ
.wrap

% c-sdk {
/**
    Initializes the clock_enable PIO program
    @param pio PIO engine to use
    @param sm State machine number
    @param offset State machine program offset
**/
static inline void clock_enable_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = clock_enable_program_get_default_config(offset);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}



;Simple program to generate a 500KHz TX clock
.program clock_tx
; Should run at 1Mhz
.side_set 1
.wrap_target

wait 0 irq CLK_ENABLE_IRQ side 0    ; Push clock to 0 and wait for clock to be enabled
nop side 1 [1]                      ; Push clock to 1
irq CLK_INTERRUPT side 0            ; Push clock to 0 and rise interrupt for hdlc_tx program 

.wrap

% c-sdk {
/**
    Initializes the clock_tx PIO program
    @param pio PIO engine to use
    @param sm State machine number
    @param offset State machine program offset
    @param clkPin Clock pin
**/
static inline void clock_tx_program_init(PIO pio, uint sm, uint offset, uint clkPin) {
    pio_sm_config c = clock_tx_program_get_default_config(offset);

    // Only one out pin used for clock
    pio_sm_set_consecutive_pindirs(pio, sm, clkPin, 1, true);
    pio_gpio_init(pio, clkPin);
    sm_config_set_sideset_pins(&c, clkPin);

    //Sets the clock divider to have 1Mhz (we are using 2 instructions)
    sm_config_set_clkdiv(&c, 62.5f);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}

; Program to send data to HDLC bus
.program hdlc_tx
.wrap_target
send_flag_first_zero:
; Send the flag
irq FLAG_SENT_IRQ           ; Raise IRQ as we need clock
wait 1 irq CLK_INTERRUPT    ; Waits for the clock to be low
set pins, 0                 ; Sets the pin to 0
set x, 5                    ; Prepare to send 6 consecutive ones
set y, 5                    ; Prepare to send no more than 5 ones
send_flag_ones:
wait 1 irq CLK_INTERRUPT    ; Waits for the clock to be low
set pins, 1                 ; Sets the pin to 1
jmp x-- send_flag_ones      ; Loop until we send 6 ones
send_flag_last_zero:
;Send the remaining 0
wait 1 irq CLK_INTERRUPT    ; Waits for the clock to be low
set pins, 0                 ; Sets the pin to 0
;Wait for OSR to be filled
jmp !osre tx_data           ; Jump to tx_data if OSR is not empty
wait 1 irq FLAG_SENT_IRQ    ; Clear the IRQ to disable clock
jmp send_flag_first_zero    ; OSR empty send flag again

tx_data:
out x, 1                    ; Get one bit from OSR
jmp !x tx_zero              ; Jump to tx_zero if we have a 0
;Got a one
jmp y-- tx_one              ; Send a one if not 5 ones in a row
; Sent 5 consective one, need to send an extra 0
wait 1 irq CLK_INTERRUPT    ; Waits for the clock to be low
set pins, 0                 ; Sets the pin to 0
set y, 4                    ; Reset one counter to 4 for counting 5 ones (taking into account next 1)
tx_one:
wait 1 irq CLK_INTERRUPT    ; Waits for the clock to be low
set pins, 1                 ; Sets the pin to 1
jmp !osre tx_data           ; Jump to tx_data if OSR is not empty
jmp send_flag_first_zero    ; TX completed, send flag

tx_zero:
wait 1 irq CLK_INTERRUPT    ; Waits for the clock to be low
set pins, 0                 ; Sets the pin to 0
set y, 5                    ; Reset one counter to 4 for counting 5 ones
jmp !osre tx_data           ; Jump to tx_data if OSR is not empty
.wrap                       ; TX completed, send flag

% c-sdk {
/**
    Initializes the hdlc_tx PIO program
    @param pio PIO engine to use
    @param sm State machine number
    @param offset State machine program offset
    @param dataPin Data pin
**/
static inline void hdlc_tx_program_init(PIO pio, uint sm, uint offset, uint dataPin) {
    pio_sm_config c = hdlc_tx_program_get_default_config(offset);

    // Only one out pin used for data
    pio_sm_set_consecutive_pindirs(pio, sm, dataPin, 1, true);
    sm_config_set_set_pins(&c, dataPin, 1);
    pio_gpio_init(pio, dataPin);
    
    //Configure the TX FIFO
    //Join TX and RX FIFO as we only do TX
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
    //Shift right, with autopush threshold of 8 bits
    sm_config_set_out_shift(&c, true, true, 8);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}